<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Butterfly Classification (PyScript)</title>

    <link rel="stylesheet" href="https://pyscript.net/releases/2024.3.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.3.1/core.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f9f9f9;
        }

        .container {
            max-width: 500px;
            margin: auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
        }

        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        #result {
            display: none;
            margin-top: 20px;
        }

        #result img {
            max-width: 100%;
            border-radius: 10px;
            max-width: 300px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Butterfly Classification</h1>
        <form id="uploadForm">
            <input type="file" id="imageUpload" accept="image/*">
            <button type="button" py-click="upload_and_classify">Upload & Classify</button>
        </form>

        <div id="result">
            <h2>Prediction Result</h2>
            <img id="uploadedImage" src="" alt="Uploaded Image">
            <p id="classification"></p>
            <p id="loadingMessage" style="color: blue; display: none;">Loading model and predicting...</p>
        </div>
    </div>

    <py-config>
        packages = ["numpy", "Pillow", "tensorflowjs"]
    </py-config>

    <py-script>
import js
from pyodide.ffi import to_js
from PIL import Image
import numpy as np
import io

# Define the butterfly names (make sure this order matches your model's output)
butterfly_names = [
    'Butterfly-Clippers',
    'Butterfly-Common Jay',
    'Butterfly-Common Lime',
    'Butterfly-Common Mime',
    'Butterfly-Common Mormon',
    'Butterfly-Emerald Swallowtail',
    'Butterfly-Golden Birdwing',
    'Butterfly-Gray Glassy Tiger',
    'Butterfly-Great Eggfly',
    'Butterfly-Great Yellow Mormon',
    'Butterfly-Paper Kite',
    'Butterfly-Pink Rose',
    'Butterfly-Plain Tiger',
    'Butterfly-Red Lacewing',
    'Butterfly-Scarlet Mormon',
    'Butterfly-Tailed Jay',
    'Moth-Atlas',
    'Moth-Giant Silk'
]

# Global variable to store the loaded model
model = None

async def load_model():
    global model
    if model is None:
        try:
            # Await the loading of the TensorFlow.js model
            # This still uses the TF.js global object exposed via 'js'
            model_url = 'http://localhost:8000/model/butterfly.json'
            loading_message = js.document.getElementById('loadingMessage')
            loading_message.style.display = 'block'
            loading_message.innerText = 'Loading AI model...'

            model = await js.tf.loadLayersModel(model_url)
            js.console.log('Model loaded successfully in PyScript!')
            loading_message.style.display = 'none'
        except Exception as e:
            js.console.error(f"Error loading model: {e}")
            js.document.getElementById('classification').innerText = f"Error loading model: {e}"
            loading_message.style.display = 'none'
    return model

async def upload_and_classify():
    input_element = js.document.getElementById('imageUpload')
    uploaded_image_element = js.document.getElementById('uploadedImage')
    result_div = js.document.getElementById('result')
    classification_p = js.document.getElementById('classification')
    loading_message = js.document.getElementById('loadingMessage')

    if not input_element.files:
        js.alert('Please select an image to classify.')
        return

    file = input_element.files.item(0) # Get the first selected file

    if not file:
        js.alert('No file selected or file access denied.')
        return

    reader = js.FileReader.new()

    # Define an async function to handle the file reading completion
    async def on_reader_load(event):
        nonlocal model # Allows modification of the global model variable
        
        image_data_url = event.target.result
        uploaded_image_element.src = image_data_url
        result_div.style.display = 'block'
        classification_p.innerText = 'Classifying...'
        loading_message.style.display = 'block'
        loading_message.innerText = 'Predicting...'

        try:
            # Ensure the model is loaded
            model = await load_model()
            if model is None:
                raise Exception("Model could not be loaded.")

            # Load image using PIL (Pillow) from the data URL
            # Need to remove the 'data:image/jpeg;base64,' part
            base64_data = image_data_url.split(',')[1]
            image_bytes = io.BytesIO(js.atob(base64_data).encode('latin-1'))
            pil_image = Image.open(image_bytes).convert('RGB')
            
            # Resize and preprocess the image for the model
            pil_image = pil_image.resize((180, 180)) # Match model input size
            img_array = np.array(pil_image) / 255.0  # Normalize to [0, 1]
            
            # Convert NumPy array to TensorFlow.js tensor
            # Reshape for batch dimension (1, height, width, channels)
            tensor = js.tf.tensor(to_js(img_array.tolist()), shape=[1, 180, 180, 3], dtype='float32')
            
            # Make prediction
            prediction = model.predict(tensor)
            probabilities = await prediction.data() # Get data as a JS Array
            
            # Convert JS Array back to Python list for numpy argmax
            probabilities_py = np.array(list(probabilities))
            predicted_class_index = np.argmax(probabilities_py)
            
            if 0 <= predicted_class_index < len(butterfly_names):
                predicted_class_name = butterfly_names [predicted_class_index]
                confidence = (probabilities_py[predicted_class_index] * 100).toFixed(2)
                classification_p.innerText = f"The image belongs to {predicted_class_name} with a confidence of {confidence}%"
            else:
                classification_p.innerText = "Error: Predicted class index out of bounds."
                js.console.error(f"Predicted class index: {predicted_class_index}")
            
            # Dispose of tensors to free up memory
            tensor.dispose()
            prediction.dispose()

        except Exception as e:
            js.console.error(f"Error during classification: {e}")
            classification_p.innerText = f"Error during classification: {e}"
        finally:
            loading_message.style.display = 'none' # Hide loading message

    # Set the onload handler and read the file
    reader.onload = to_js(on_reader_load) # Convert Python function to JS callback
    reader.readAsDataURL(file)
    </py-script>
</body>

</html>